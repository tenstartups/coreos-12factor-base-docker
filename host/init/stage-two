#!/bin/bash
set -e

# This is the second stage initialization and is responsible for bringing up the
# application from scrach, which includes downloading required docker images and
# running services.  The second stage is divided into separate configs and/or
# scripts located in the init.d directory, which are executed in alphabetical
# order serially.  Note however that cloud-config yml initializers are spawned
# in parallel and cannot be guaranteed to run in order.

# Abort stage two if environment is set
if [ "${ABORT_PARASITE_INIT_STAGE_TWO}" = "true" ]; then
  echo >&2 "Aborting parasite stage two initialization per ABORT_PARASITE_INIT_STAGE_TWO environment variable"
  exit 1
fi

# Create the default bridge network and extract the bridge network address
DOCKER_VERSION=$(docker version --format '{{.Server.Version}}')
if [[ ${DOCKER_VERSION} =~ ^1\s*\.[0-9]\.[0-9]+\s*$ ]]; then
  DOCKER_BRIDGE_NETWORK_NAME=bridge
  DOCKER_BRIDGE_NETWORK_ADDRESS=$(ip addr show docker0 | grep "inet " | sed -Ee 's/^\s*inet\s+([.0-9]+)\/[0-9]+\s+.+$/\1/')
else
  DOCKER_BRIDGE_NETWORK_NAME=parasite
  /usr/bin/docker network rm ${DOCKER_BRIDGE_NETWORK_NAME} || true
  /usr/bin/docker network create --driver=bridge ${DOCKER_BRIDGE_NETWORK_NAME}
  DOCKER_BRIDGE_NETWORK_ADDRESS=$(docker network inspect --format "{{range .IPAM.Config}}{{.Gateway}}{{end}}" ${DOCKER_BRIDGE_NETWORK_NAME} | sed -Ee 's/()(\/[0-9]+)/\1/')
fi
cat << EOF >> "<%= getenv!(:config_directory) %>/env/systemd.env"
#
# Additional docker network configuration variables
DOCKER_VERSION=${DOCKER_VERSION}
DOCKER_BRIDGE_NETWORK_NAME=${DOCKER_BRIDGE_NETWORK_NAME}
DOCKER_BRIDGE_NETWORK_ADDRESS=${DOCKER_BRIDGE_NETWORK_ADDRESS}
EOF
cat << EOF >> "<%= getenv!(:config_directory) %>/env/profile.sh"
#
# Additional docker network configuration variables
export DOCKER_VERSION=${DOCKER_VERSION}
export DOCKER_BRIDGE_NETWORK_NAME=${DOCKER_BRIDGE_NETWORK_NAME}
export DOCKER_BRIDGE_NETWORK_ADDRESS=${DOCKER_BRIDGE_NETWORK_ADDRESS}
EOF
export DOCKER_VERSION=${DOCKER_VERSION}
export DOCKER_BRIDGE_NETWORK_NAME=${DOCKER_BRIDGE_NETWORK_NAME}
export DOCKER_BRIDGE_NETWORK_ADDRESS=${DOCKER_BRIDGE_NETWORK_ADDRESS}

# Pre-pull all docker images at the start to ensure a smoother initialization
echo "Pre-pulling all required docker images"
systemctl start docker-check-image-update.service
echo "Finished pre-pulling all required docker images"

# Notify that we started
/opt/bin/send-notification warn "Starting \`docker-parasite\` initialization"

# Delete the existing parasite configiguration container unless explicitly prevented
if [ "${KEEP_EXISTING_PARASITE_CONFIG}" != "true" ]; then
  /opt/bin/docker-check-remove ${DOCKER_CONTAINER_PARASITE_CONFIG}
fi

# Create the parasite configuration volume container if not alreay created
if ! [ -z "${DOCKER_IMAGE_PARASITE_CONFIG}" ] && ! [ -z "${DOCKER_CONTAINER_PARASITE_CONFIG}" ]; then
  /opt/bin/docker-check-pull ${DOCKER_IMAGE_PARASITE_CONFIG}
  if [ -z "$(docker ps --no-trunc -a -q -f label=${DOCKER_CONTAINER_PARASITE_CONFIG})" ] && \
     [ -z "$(docker ps --no-trunc -a -q -f label=${DOCKER_CONTAINER_PARASITE_CONFIG/-/_})" ]; then
    /usr/bin/docker run \
      --label ${DOCKER_VOLUME_CONTAINER_LABEL} \
      --label ${DOCKER_CONTAINER_PARASITE_CONFIG/-/_} \
      --volume <%= getenv!(:config_directory) %> \
      --env-file=/parasite-config.env \
      --net ${DOCKER_BRIDGE_NETWORK_NAME} \
      --hostname ${DOCKER_HOSTNAME} \
      --name ${DOCKER_CONTAINER_PARASITE_CONFIG} \
      ${DOCKER_IMAGE_PARASITE_CONFIG} \
      container
  fi
fi

# Create the parasite data volume container if not already created
if ! [ -z "${DOCKER_IMAGE_PARASITE_DATA}" ] && ! [ -z "${DOCKER_CONTAINER_PARASITE_DATA}" ]; then
  /opt/bin/docker-check-pull ${DOCKER_IMAGE_PARASITE_DATA}
  if [ -z "$(docker ps --no-trunc -a -q -f label=${DOCKER_CONTAINER_PARASITE_DATA})" ] && \
     [ -z "$(docker ps --no-trunc -a -q -f label=${DOCKER_CONTAINER_PARASITE_DATA/-/_})" ]; then
    /usr/bin/docker create \
      --label ${DOCKER_VOLUME_CONTAINER_LABEL} \
      --label ${DOCKER_CONTAINER_PARASITE_DATA/-/_} \
      --volume <%= getenv!(:data_directory) %> \
      --name ${DOCKER_CONTAINER_PARASITE_DATA} \
      ${DOCKER_IMAGE_PARASITE_DATA}
    # Load data from a backup tar file if present
    if [ -f "/parasite-data.tar.gz" ]; then
      /opt/bin/docker-check-pull ${DOCKER_IMAGE_SHELL}
      docker run --rm \
        --volumes-from ${DOCKER_CONTAINER_PARASITE_DATA} \
        -v /parasite-data.tar.gz:/parasite-data.tar.gz \
        ${DOCKER_IMAGE_SHELL} \
        sh -c 'cd <%= getenv!(:data_directory) %> && tar xvzf /parasite-data.tar.gz'
    fi
  fi
fi

# Start base systemd services and wait
systemctl start install-tools.service &
<% if getenv!(:parasite_os) == 'coreos' %>___ERB_REMOVE_LINE___
if ! [ -z "${SWAP_FILE}" ] && ! [ -z "${SWAP_SIZE_MB}" ]; then
  systemctl start swapfile.service &
fi
if ! [ -z "${NEWRELIC_LICENSE_KEY}" ]; then
  systemctl start newrelic-agent.service &
fi
if [ -f "<%= getenv!(:config_directory) %>/env/etcd.env" ]; then
  systemctl start etcdd.service &
fi
<% end %>___ERB_REMOVE_LINE___
wait

# Execute each initialization cloud-config or script in alphabetical order
find "<%= getenv!(:config_directory) %>/init.d" -type f | sort | uniq | while read file; do
  <% if getenv!(:parasite_os) == 'coreos' %>___ERB_REMOVE_LINE___
  if [[ "$file" == *.yml ]]; then
    echo "Executing parasite initialization cloud-config $file..."
    coreos-cloudinit --from-file="$file"
  fi
  <% end %>___ERB_REMOVE_LINE___
  if [[ "$file" == *.sh ]]; then
    echo "Executing parasite initialization script $file..."
    "$file"
  fi
done

# Start services listed in the systemd start file
if [ -f "<%= getenv!(:config_directory) %>/systemd/start" ]; then
  cat "<%= getenv!(:config_directory) %>/systemd/start" | sort | while read unit; do
    systemctl start $unit &
  done
  wait
fi

# Notify that we finished
/opt/bin/send-notification success "Finished \`docker-parasite\` initialization"

exit 0
